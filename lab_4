(define call/cc call-with-current-continuation)
(define char-letter? char-alphabetic?)
(define char-digit? char-numeric?)
(define-syntax safe-cons
  (syntax-rules()
    ((safe-cons head tail)
     (let*
         ((gl head)
          (hv tail))
       (cons gl hv)))))
;; Управление стеком
(define (list-drop lst)
  (and (> (length lst) 0) (cdr lst)));;changed length 1 -> 0 ('(element) -> '())
(define (list-swap lst)
  (and (> (length lst) 1) (safe-cons (cadr lst) (safe-cons (car lst) (cddr lst)))))
(define (list-dup lst)
  (cons (car lst) (safe-cons (car lst) (cdr lst))))
(define (list-over lst)
  (and (> (length lst) 1) (safe-cons (cadr (reverse lst)) (cdr list))))
(define (list-rot lst)
  (and (> (length lst) 2) (safe-cons (caddr lst) (safe-cons (cadr lst) (safe-cons (car lst) (cdddr lst))))))
(define (list-depth lst)
  (safe-cons (length lst) lst))
;;
(define (interpret program stack)
  (do-all (vector->list program) (vector->list program) 0 stack '() '()))

(define (interpret-define arr-words now-program word-counter stack-data stack-return dict)
  (let ((x (car now-program)))
    ;   (if (= first? 1)
    ;      (interpret-define (cadr now-program) arr-words (cdr now-program) (+ 1 word-counter) stack-data (append stack-return (list x)) dict))))
    (if (= word-counter 10)
        (begin (write stack-return)
               (write now-program))
        (if (equal? x 'end)
            (do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data '() (cons  (cons  (car stack-return)  (list (cdr stack-return))) dict))
#|
            (begin (write stack-return)
                   (newline)
                   (write now-program)
                   (newline)
                   (set! dict (cons  (cons  (cadr stack-return)  (list (cddr stack-return))) dict))
                   (write dict)
                   (newline)
                   (write (assq 'x dict))
                   (newline)
                   (display (cadr (assq 'x dict))))
|#
#|
> (interpret-define 0 '() '(define x + 100 12 -1 end) 0 '() '() '((y (10))))
(define x + 100 12 -1)
(end)
((x (+ 100 12 -1)) (y (10)))
(x (+ 100 12 -1))
(+ 100 12 -1)
|#
            (interpret-define arr-words (cdr now-program) (+ 1 word-counter) stack-data (append stack-return (list x)) dict)))))
#|
> (assoc 'y '((x (10 + 12 - 20 / 0)) (y (10))))
(y (10))
> (assq 'y '((x (10 + 12 - 20 / 0)) (y (10))))
(y (10))
> (assq 'x '((x (10 + 12 - 20 / 0)) (y (10))))
(x (10 + 12 - 20 / 0))
|#
     

(define (func-call curr-stack dict)
  (if (assoc func-call dict)
      (do-all curr-stack curr-stack 0 '() '() dict)))

#|
(define (last-two-elements-of-list xs)
  (let ((reversed-xs (reverse xs)))
    (list (cadr reversed-xs) (car reversed-xs) )))
|#
  
(define (do-all arr-words now-program word-counter stack-data stack-return dict)
  (let ((program arr-words))
    (cond((=(length arr-words)word-counter)  (display stack-data))
         ; Управляющие конструкции
         ;((and (equal? (car now-program) 'define) (not (null? (cdr now-program))))
          ;(if (assoc (cdr now-program) dict)
              ;(do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (func-call stack-data dict) stack-data) stack-return (safe-cons (list (cadr now-program)) dict))
              ;(do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data stack-return (safe-cons (list (cadr now-program)) dict))))
         ;((equal? (car now-program) 'end)
          ;(do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data stack-return (safe-cons (reverse (car dict)) (cdr dict))))
         ;((not (equal? '(caar dict) 'end))
          ;(do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data stack-return (safe-cons (safe-cons (car now-program) (car dict)) (cdr dict))))
         ;((equal? (car now-program) 'exit)
          ;(do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data stack-return dict))
         ((number? (car now-program))
          (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (car now-program) stack-data)  stack-return dict))
         (else (let ((x (car now-program)))
                 (cond 
                   ;; Aрифметические операции
                   ((equal? x '+)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (+ (car stack-data) (cadr stack-data)) (cddr stack-data)) stack-return dict))
                   ((equal? x '-)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (- (car stack-data) (cadr stack-data)) (cddr stack-data))  stack-return dict))
                   ((equal? x '*)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (* (car stack-data) (cadr stack-data)) (cddr stack-data))  stack-return dict))
                   ((equal? x '/)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (/ (car stack-data) (cadr stack-data)) (cddr stack-data))  stack-return dict))
                   ((equal? x 'mod)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (remainder (car stack-data) (cadr stack-data)) (cddr stack-data))  stack-return dict))
                   ((equal? x 'neg)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (- (car stack-data)) (cdr stack-data))  stack-return dict))
                   ;; Операции сравнения
                   ;; #f <=> 0; #t <=> -1
                   ((equal? x '=)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (if (= (car stack-data) (cadr stack-data)) 0 -1) (cddr stack-data))  stack-return dict))
                   ((equal? x '>)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (if (> (car stack-data) (cadr stack-data)) 0 -1) (cddr stack-data))  stack-return dict))
                   ((equal? x '<)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (safe-cons (if (< (car stack-data) (cadr stack-data)) 0 -1) (cddr stack-data))  stack-return dict))
                   ;; Логические операции
                   ((equal? x 'not)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (cons (if (= (car stack-data) 0) 0 -1) (cddr stack-data))  stack-return dict))
                   ((equal? x 'and)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter)
                            (cons (if (or (= (car stack-data) 0) (= (cadr stack-data) 0)) 0 -1) (cddr stack-data))  stack-return dict))
                   ((equal? x 'or)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter)
                            (cons (if (and (= (car stack-data) 0) (= (cadr stack-data) 0)) 0 -1) (cddr stack-data))  stack-return dict))
                   ;;Операции со стеком
                   ((equal? x 'drop)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-drop stack-data)  stack-return dict))
                   ((equal? x 'swap)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-swap stack-data)  stack-return dict))
                   ((equal? x 'dup)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-dup stack-data)  stack-return dict))
                   ((equal? x 'over)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-over stack-data)  stack-return dict))
                   ((equal? x 'rot)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-rot stack-data)  stack-return dict))
                   ((equal? x 'depth)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) (list-depth stack-data) stack-return dict))
                   ((equal? x 'define)
                    (interpret-define arr-words (cdr now-program)(+ 1 word-counter) stack-data stack-return dict))
                   ((assq x dict)
                    ;(do-all (safe-cons arr-words (cdr (assq x dict))) (safe-cons (cdr (assq x dict)) (cdr now-program)) (+ 1 word-counter) stack-data stack-return dict)
                    (interpret (list->vector (cadr (assq x dict))) stack-data)
                    (do-all arr-words (cdr now-program) (+ 1 word-counter) stack-data stack-return dict)
                    (newline))
                    ;(display (cadr (assq x dict))))
                   (else (display 'coming_soon)(display dict))))))))


